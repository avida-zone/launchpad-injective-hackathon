/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.26.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

export type Addr = string;
export type WBTreeSetForString = string[];
export type WPredicateType = "GE" | "LE" | "GT" | "LT";
export type WBTreeSetForWPredicate = WPredicate[];
export interface InstantiateMsg {
  launchpad: Addr;
  vectis_cred_schema: WCredentialSchema;
  vectis_non_cred_schema: WNonCredentialSchema;
  vectis_sub_proof_request: WSubProofReq;
}
export interface WCredentialSchema {
  attrs: WBTreeSetForString;
  [k: string]: unknown;
}
export interface WNonCredentialSchema {
  attrs: WBTreeSetForString;
  [k: string]: unknown;
}
export interface WSubProofReq {
  predicates: WBTreeSetForWPredicate;
  revealed_attrs: WBTreeSetForString;
  [k: string]: unknown;
}
export interface WPredicate {
  attr_name: string;
  p_type: WPredicateType;
  value: number;
  [k: string]: unknown;
}
export type ExecuteMsg = {
  verify: {
    proof: WProof;
    proof_req_nonce: BigNumberBytes;
    wallet_addr: Addr;
  };
};
export type BigNumberBytes = string;
export type PointG1Bytes = string;
export type PointG2Bytes = string;
export type WMap = [number[], BigNumberBytes][];
export interface WProof {
  aggregated_proof: WAggregatedProof;
  proofs: WSubProof[];
  [k: string]: unknown;
}
export interface WAggregatedProof {
  c_hash: BigNumberBytes;
  c_list: number[][];
  [k: string]: unknown;
}
export interface WSubProof {
  non_revoc_proof?: WNonRevocProof | null;
  primary_proof: WPrimaryProof;
  [k: string]: unknown;
}
export interface WNonRevocProof {
  c_list: [PointG1Bytes[], PointG2Bytes[]];
  x_list: WGroupOrderElement[];
  [k: string]: unknown;
}
export interface WGroupOrderElement {
  bn_hex: string;
  [k: string]: unknown;
}
export interface WPrimaryProof {
  eq_proof: WPrimaryEqualProof;
  ne_proofs: WPrimaryPredicateInequalityProof[];
  [k: string]: unknown;
}
export interface WPrimaryEqualProof {
  a_prime: BigNumberBytes;
  e: BigNumberBytes;
  m: WMap;
  m2: BigNumberBytes;
  revealed_attrs: WMap;
  v: BigNumberBytes;
  [k: string]: unknown;
}
export interface WPrimaryPredicateInequalityProof {
  alpha: BigNumberBytes;
  mj: BigNumberBytes;
  predicate: WPredicate;
  r: WMap;
  t: WMap;
  u: WMap;
  [k: string]: unknown;
}
export type QueryMsg = string;
